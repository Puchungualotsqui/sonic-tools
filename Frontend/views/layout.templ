package views

import (
	 "frontend/components/header"
	"frontend/components/footer"
	"frontend/static/data"
)

templ Layout(content, metaData templ.Component, formats []data.Format) {
	<!DOCTYPE html>
		<html lang="en">
		<head>
			<meta charset="utf-8" />
    		<meta name="viewport" content="width=device-width, initial-scale=1" />

      		<link rel="icon" href="/favicon.ico" sizes="any">


			@metaData

			<!-- Tailwind + DaisyUI -->
			<link href="/static/css/output.css" rel="stylesheet">


			<!-- HTMX -->
			<script src="https://unpkg.com/htmx.org@1.9.10"></script>

			<!-- Alpine.js -->
			<script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js" defer></script>

			<script>
            document.addEventListener("DOMContentLoaded", () => {
              document.body.addEventListener("htmx:afterSwap", (e) => {
                if (e.detail.target.id === "body-container") {
                  // Reset uploader store when switching tools
                  Alpine.store('uploader').files = [];
                  Alpine.store('uploader').rejectedCount = 0;

                  // Also reset hidden file input if you want
                  const input = document.querySelector('#fileInput');
                  if (input) input.value = '';
                }
              });
            });
            </script>


            <script defer>
              document.addEventListener('alpine:init', () => {
                Alpine.store('uploader', {
                  files: [],
                  rejectedCount: 0,
                  // keep the dots for endsWith() to work consistently
                  allowedExts: ['.mp3', '.wav', '.flac', '.ogg', '.opus', '.aiff', '.aac', '.m4a', '.wma'],

                  // limits
                  MAX_FILES: 10,
                  MAX_TOTAL_BYTES: 50 * 1024 * 1024, // 50 MB

                  addFiles(fileList) {
                    const incoming = Array.from(fileList);
                    let rejects = 0;

                    incoming.forEach(f => {
                      // reject if extension not allowed
                      if (!this.isAllowed(f)) { rejects++; return; }

                      // reject if we'd exceed file count
                      if (this.files.length >= this.MAX_FILES) { rejects++; return; }

                      // reject if we'd exceed total size budget
                      if (this.totalBytes() + f.size > this.MAX_TOTAL_BYTES) { rejects++; return; }

                      // de-dup by stable id
                      const id = `${f.name}-${f.size}-${f.lastModified}`;
                      if (!this.files.some(x => x.id === id)) {
                        this.files.push({ id, file: f, progress: 0 });
                      }
                    });

                    this.rejectedCount += rejects;
                  },

                  removeFile(id) {
                    this.files = this.files.filter(f => f.id !== id);
                  },

                  reset() {
                    this.files = [];
                    this.rejectedCount = 0;
                    const input = document.querySelector('#fileInput');
                    if (input) input.value = '';
                  },

                  isAllowed(file) {
                    const name = file.name.toLowerCase();
                    return this.allowedExts.some(ext => name.endsWith(ext));
                  },

                  totalBytes() {
                    return this.files.reduce((sum, item) => sum + item.file.size, 0);
                  },

                  formatSize(bytes) {
                    return (bytes / 1024 / 1024).toFixed(2) + ' MB';
                  },

                  async upload() {
                    if (this.files.length === 0) return;

                    const form = document.querySelector('#toolForm');
                    let settingsJSON = "{}";

                    if (form) {
                      const settingsObj = {};
                      new FormData(form).forEach((value, key) => {
                        if (key === "files" || key === "cover") return;

                        if (settingsObj[key]) {
                          if (Array.isArray(settingsObj[key])) {
                            settingsObj[key].push(value);
                          } else {
                            settingsObj[key] = [settingsObj[key], value];
                          }
                        } else {
                          settingsObj[key] = value;
                        }
                      });

                      settingsObj["fileOrder"] = this.files.map(f => f.file.name);
                      settingsObj["tool"] = (window.location.pathname.replace("/", "").split("-")[0]) || "home";

                      settingsJSON = JSON.stringify(settingsObj);
                    }

                    const formData = new FormData();
                    this.files.forEach(item => {
                      formData.append("files", item.file);
                    });
                    formData.append("settings", settingsJSON);

                    const coverInput = form?.querySelector('input[name="cover"]');
                    if (coverInput && coverInput.files.length > 0) {
                      formData.append("cover", coverInput.files[0]);
                    }

                    const xhr = new XMLHttpRequest();
                    xhr.open("POST", "/api/upload", true);
                    xhr.responseType = "blob";

                    xhr.upload.onprogress = (e) => {
                      if (e.lengthComputable) {
                        const progress = (e.loaded / e.total) * 100;
                        this.files.forEach(item => item.progress = progress);
                      }
                    };

                    xhr.onload = () => {
                      if (xhr.status === 200) {
                        const blob = xhr.response;
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement("a");
                        a.href = url;

                        const disposition = xhr.getResponseHeader("Content-Disposition");
                        let filename = "sonic-tools.zip";
                        if (disposition && disposition.includes("filename=")) {
                          filename = disposition.split("filename=")[1].replace(/"/g, "");
                        }
                        a.download = filename;
                        a.click();
                        URL.revokeObjectURL(url);

                        this.files.forEach(item => item.progress = 100);
                        this.reset();
                      } else {
                        console.error("Upload failed", xhr.statusText);
                      }
                    };

                    xhr.onerror = () => console.error("Network error");
                    xhr.send(formData);
                  }
                });
              });
            </script>

		</head>
		<body class="min-h-screen flex flex-col bg-base-200" x-data>
			<div id="header-container">
				@header.Header(formats)

			</div>
			<div id="body-container">
				@content
			</div>

			<div id="footer-container" >
				@footer.Footer()
			</div>
			</body>
		</html>

		<script>


		</script>
}
