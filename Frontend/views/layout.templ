package views

import (
	 "frontend/components/header"
	"frontend/components/footer"
)

templ Layout(content templ.Component) {
	<!DOCTYPE html>
		<html lang="en">
		<head>
			<meta charset="UTF-8" />
			<meta name="viewport" content="width=device-width, initial-scale=1.0" />
			<title>Hello World</title>

			<!-- Tailwind + DaisyUI -->
			<script src="https://cdn.tailwindcss.com"></script>
			<link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.css" rel="stylesheet" />

			<!-- HTMX -->
			<script src="https://unpkg.com/htmx.org@1.9.10"></script>

			<!-- Alpine.js -->
			<script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js" defer></script>

			<script>
            document.addEventListener("DOMContentLoaded", () => {
              document.body.addEventListener("htmx:afterSwap", (e) => {
                if (e.detail.target.id === "body-container") {
                  // Reset uploader store when switching tools
                  Alpine.store('uploader').files = [];
                  Alpine.store('uploader').rejectedCount = 0;

                  // Also reset hidden file input if you want
                  const input = document.querySelector('#fileInput');
                  if (input) input.value = '';
                }
              });
            });
            </script>


  <script defer>
  document.addEventListener('alpine:init', () => {
    Alpine.store('uploader', {
      files: [],
      rejectedCount: 0,
      allowedExts: ['.mp3', '.wav', '.flac', '.ogg', '.aac', '.m4a'],

      addFiles(fileList) {
        const incoming = Array.from(fileList);
        let rejects = 0;

        incoming.forEach(f => {
          if (!this.isAllowed(f)) { rejects++; return; }
          const id = `${f.name}-${f.size}-${f.lastModified}`;
          if (!this.files.some(x => x.id === id)) {
            this.files.push({ id, file: f, progress: 0 });
          }
        });

        this.rejectedCount += rejects;
      },

      reset() {
        this.files = []
        this.rejectedCount = 0

        // clear the actual input element
        const input = document.querySelector('#fileInput')
        if (input) input.value = ''
      },

      isAllowed(file) {
        return this.allowedExts.some(ext => file.name.toLowerCase().endsWith(ext));
      },

      formatSize(bytes) {
        return (bytes / 1024 / 1024).toFixed(2) + ' MB';
      },

      async upload() {
        if (this.files.length === 0) return;

        const form = document.querySelector('#toolForm');
        let settingsJSON = "{}"; // default empty
        if (form) {
          const settingsObj = {};
          new FormData(form).forEach((value, key) => {
            if (key === "files" || key === "cover") return;

            if (settingsObj[key]) {
              if (Array.isArray(settingsObj[key])) {
                settingsObj[key].push(value);
              } else {
                settingsObj[key] = [settingsObj[key], value];
              }
            } else {
              settingsObj[key] = value;
            }
          });

          settingsObj["fileOrder"] = this.files.map(f => f.file.name);
          settingsObj["tool"] = window.location.pathname.replace("/", "") || "home";

          settingsJSON = JSON.stringify(settingsObj);
        }

        // Build a single FormData with ALL files
        const formData = new FormData();
        this.files.forEach(item => {
          formData.append("files", item.file); // multiple "files" entries
        });
        formData.append("settings", settingsJSON);

        const coverInput = form.querySelector('input[name="cover"]');
        if (coverInput && coverInput.files.length > 0) {
          formData.append("cover", coverInput.files[0]);
        }

        const xhr = new XMLHttpRequest();
        xhr.open("POST", "/api/upload", true);
        xhr.responseType = "blob";

        xhr.upload.onprogress = (e) => {
          if (e.lengthComputable) {
            const progress = (e.loaded / e.total) * 100;
            // update progress for all items
            this.files.forEach(item => item.progress = progress);
          }
        };

        xhr.onload = () => {
          if (xhr.status === 200) {
            const blob = xhr.response;
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;

            const disposition = xhr.getResponseHeader("Content-Disposition");
            let filename = "sonic-tools.zip"; // default
            if (disposition && disposition.includes("filename=")) {
              filename = disposition.split("filename=")[1].replace(/"/g, "");
            }
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);

            this.files.forEach(item => item.progress = 100);

            this.reset()
          } else {
            console.error("Upload failed", xhr.statusText);
          }
        };

        xhr.onerror = () => console.error("Network error");
        xhr.send(formData);
      }
    });
  });
</script>
		</head>
		<body class="min-h-screen flex flex-col bg-base-200" x-data>
			<div id="header-container">
				@header.Header()
			</div>
			<div id="body-container">
				@content
			</div>

			<div id="footer-container" >
				@footer.Footer()
			</div>
			</body>
		</html>

		<script>


		</script>
}
